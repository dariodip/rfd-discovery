\documentclass[11pt]{article}

\usepackage{graphicx}
\usepackage[italian,english]{babel}
\usepackage{cite}
\usepackage{algorithm2e}
\usepackage{amsthm}
\usepackage[utf8]{inputenc}
\usepackage{setspace}
\renewcommand{\baselinestretch}{1.3} 

\newtheorem{theorem}{Theorem}[section]

\begin{document}
	%% Frontespizio
	\begin{titlepage}
		\begin{center}
			\includegraphics[width=2cm]{img/logo.jpg}\\[0.2truecm]
			\setstretch{1}{ \Large Università degli Studi di Salerno}\\[0.2truecm]
			{\large Dipartimento d'Informatica}\\
			\hrulefill \\[0.2truecm]
			{\large Corso di Laurea Magistrale in Informatica}\\[0.2truecm]
			{\large Intelligenza Artificiale }\\[3truecm]
			
			\vfill
			{\Huge \textbf{Relaxed Functional Dependencies Discovery}\par }
			\vfill
			{\large \textbf{subtitle}}
			\\[3.0truecm]
			
			{\bf Relatori} \hfill {\bf Studenti}\ \ \\
			Prof. Vincenzo Deufemia \hfill Antonio~Altamura\\
			Prof. Giuseppe Polese \hfill Dario~Di Pasquale \\
			\hfill Mattia~Tomeo
			\vfill
			\hrulefill
			\hrulefill\\
			Anno Accademico 2016-2017
		\end{center}
	\end{titlepage}
	
\renewcommand*\contentsname{Indice}
\tableofcontents
\newpage

\section{Introduzione}
\subsection{Notazioni preliminari}
Uno \textit{schema di relazione} è costituito da un simbolo $R$, detto \textit{nome della relazione}, e da un insieme di \textit{attributi} $X = \left\{ A_1, A_2,\ldots, A_n \right\}$, di solito indicato con $R(X)$. A ciascun attributo è associato un dominio. \\
Uno \textit{schema di base di dati} è un insieme di schemi di relazione con nomi diversi:
\begin{center}
	\textbf{R} = $R_1(X_1), R_2(X_2), \ldots, R_n(X_n)$.
\end{center}
Una \textit{relazione} su uno schema $R(X)$ è un insieme $r$ di tuple su $X$ \cite{atzeni1999basi}.
\section{Dipendenze funzionali e dipendenze funzionali rilassate}
\subsection{Dipendenze funzionali canoniche}
Una \textit{dipendenza funzionale} è un vincolo di integrità per il modello relazionale che descrive i legami di tipo funzionale tra gli attributi di una relazione. \\
Data una relazione $r$ su uno schema $R(X)$ e due sottoinsiemi di attributi non vuoti $Y$ e $Z$ di $X$, diremo che esiste su $r$ una dipendenza funzionale tra $Y$ e $Z$, se, per ogni coppia di tuple $t_1$ e $t_2$ di $r$ aventi gli stessi valori sugli attributi $Y$, risulta che $t_1$ e $t_2$ hanno gli stessi valori sugli attributi $Z$. Una dipendenza funzionale tra gli attributi $Y$ e $Z$ viene indicata con la notazione $Y \rightarrow Z$ e viene associata a uno schema. \\
Se l'insieme $Z$ è composto da attributi $A_1, A_2, \ldots, A_k$, allora una relazione soddisfa $Y \rightarrow Z$ se e solo se essa soddisfa tutte le $k$ dipendenze $Y \rightarrow A_1$, $Y \rightarrow A_2$,..., $Y \rightarrow A_k$. Di conseguenza, quando opportuno, possiamo assumere che le dipendenze abbiano la forma $Y \rightarrow A$, in cui $A$ è un singolo attributo. \\
Una relazione funzionale è \textit{non banale} se $A$ non compare tra gli attributi di $Y$. \\
È opportuno notare che, data una chiave $K$ di una relazione $r$, si può facilmente notare che esiste una dipendenza funzionale tra $K$ ed ogni altro attributo dello schema di $r$. Quindi una dipendenza funzionale $Y \rightarrow Z$ su uno schema $R(X)$ degenera nel vincolo di chiave se l'unione di $Y$ e $Z$ è pari a $X$. In tal caso $Y$ è superchiave per lo schema $R(X)$ . \\
Diciamo che un insieme di dipendenze funzionali $F$ \textit{implica} un'altra dipendenza funzionale $f$ se ogni relazione che soddisfa tutte le dipendenze funzionali in $F$ soddisfa anche $f$. Occorre ora chiarire il modo in cui è possibile verificare se, dati $F$ ed $f$, $F$ implica $f$. \\
Dati uno schema $R(U)$ ed un insieme di dipendenze funzionali $F$ definite sugli attributi in $U$. Sia $X$ un insieme di attributi contenuti in $U$ ($X \subseteq U$); la \textit{chiusura} di $X$ rispetto ad $F$, indicata con $X^{+}_F$, è l'insieme degli attributi che dipendono funzionalmente da $X$:
\begin{eqnarray}
X_F^{+} = \left\{A | A \in U, F implica X \rightarrow A \right\}.
\end{eqnarray}
Se vogliamo vedere se $X \rightarrow A$ è implicata da $F$, basta vedere se $A$ appartiene a $X_F^{+}$, poiché l'insieme $X_F^{+}$ può essere calcolato molto facilmente mediante il seguente algoritmo:
\begin{algorithm}
	\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
	\Input{Un insieme $X$ di attributi e un insieme $F$ di dipendenze}
	\Output{Un insieme $X_p$ di attributi}
	\BlankLine
	$X_p \leftarrow X$; \\
	Se in $F$ esiste una dipendenza $Y \rightarrow A$ con $Y \subseteq X_p$ e $A \notin X_p$ allora aggiungiamo $A$ a $X_p$; \\
	Ripetiamo il passo precedente fino al momento in cui non vi sono ulteriori attributi che possono essere aggiunti a $X_p$.
	%%da formalizzare
\end{algorithm}
Può essere utile sostituire ad un insieme di dipendenze funzionali, un altro insieme che specifichi le stesse proprietà e che sia più semplice da gestire. \\
Due insiemi di dipendenze funzionali $F_1$ e $F_2$ sono \textit{equivalenti} se $F_1$ implica $F_2$ e viceversa. Se due insiemi sono equivalenti diciamo che ognuno è \textit{copertura} dell'altro. Quindi, dati due insiemi $F_1$ ed $F_2$ equivalenti, una relazione soddisfa $F_1$ se e solo se essa soddisfa $F_2$. Inoltre, un insieme di dipendenze funzionali $F$ è \textit{non ridondante} se non esiste una dipendenza $f \in F$ tale che $F - \left\{f\right\}$ implica $f$; mentre è \textit{ridotto} se non è ridondante e non esiste un insieme $F'$ equivalente ad $F$ ottenuto eliminando attributi dai primi membri di una o più dipendenze di $F$. \\
Per trovare una copertura non ridondante è sufficiente esaminare ripetutamente le dipendenze dell'insieme dato, eliminando quelle implicate da altre e fermandosi quando non ve ne sono più; l'insieme rimasto è una copertura non ridondante di quello inziale  \cite{atzeni1999basi}. \\
Per trovare una copertura ridotta, per qualunque insieme di dipendenze funzionali, possiamo procedere in tre passi:
\begin{itemize}
	\item Sostituiamo l'insieme dato con quello equivalente che ha tutti i secondi membri costituiti da singoli attributi;
	\item Eliminiamo le dipendenze ridondanti;
	\item Per ogni dipendenza verifichiamo se esistono attributi eliminabili dal primo membro; ossia, se $F$ è l'insieme corrrente, per ogni dipendenza $Y \rightarrow A \in F$, verifichiamo se esiste $Y \subseteq X$ tale che $F$ è equivalente a $F - \left\{ X \rightarrow A \right\} \cup \left\{ Y \rightarrow A \right\} $.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Dipendenze funzionali rilassate}
Una RFD $X \rightarrow Y$ si verifica su una relazione $r$ se e solo se la distanza tra due tuple $t_1$ e $t_2$ in $r$ è inferiore di una certa soglia $\alpha_A$ su ogni attributo $A \in X$, allora la loro distanza è inferiore ad una soglia $\alpha_B$ su ogni attributo $I \in Y$. 
Data una relazione $r$, la scoperta di una RFD è il problema di trovare un \textit{minimal cover set} di RFD che si verificano per $r$. Questo problema aggiunge ulteriore complessità al problema già complesso della scoperta delle dipendenze dei dati visto l'estremamente ampio spazio di ricerca dei possibili vincoli di similarità. Dunque è necessario trovare algoritmi efficienti in grado di estrarre RFD con vincoli di similarità significativi

Se i vincoli di similarità delle soglie sono conosciuti per ogni attributo del dataset, scoprire gli RFD si riduce a trovare tutte le possibili dipendenze che soddisfano la seguente regola:
\begin{center}
le partizioni di tuple che sono simili sugli attributi LHS devono corrispondere a quelli che sono simili nel RHS.
\end{center}
Questo procedimento è simile a scoprire le FD in cui si mira a trovare partizioni di tuple che condividono lo stesso valore sull'RHS se loro condividono gli stessi valori nell'LHS. 

\subsection{Scoprire le RFD per una determinata soglia}
Esistono svariati metodi per scoprire le RFD data una determinata soglia $\epsilon$.

I metodi di discovery top-down effettuano una generazione di possibili FD livello per livello e controllano se questi si verificano.

\newpage
\bibliographystyle{IEEEtran}
\bibliography{rdfsbib}
\end{document}
